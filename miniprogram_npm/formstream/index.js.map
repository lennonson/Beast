{"version":3,"sources":["formstream.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * Form Data format:\n *\n\n```txt\n--FormStreamBoundary1349886663601\\r\\n\nContent-Disposition: form-data; name=\"foo\"\\r\\n\n\\r\\n\n<FIELD-CONTENT>\\r\\n\n--FormStreamBoundary1349886663601\\r\\n\nContent-Disposition: form-data; name=\"data\"\\r\\n\nContent-Type: application/json\\r\\n\n\\r\\n\n<JSON-FORMAT-CONTENT>\\r\\n\n--FormStreamBoundary1349886663601\\r\\n\nContent-Disposition: form-data; name=\"file\"; filename=\"formstream.test.js\"\\r\\n\nContent-Type: application/javascript\\r\\n\n\\r\\n\n<FILE-CONTENT-CHUNK-1>\n...\n<FILE-CONTENT-CHUNK-N>\n\\r\\n\n--FormStreamBoundary1349886663601\\r\\n\nContent-Disposition: form-data; name=\"pic\"; filename=\"fawave.png\"\\r\\n\nContent-Type: image/png\\r\\n\n\\r\\n\n<IMAGE-CONTENT>\\r\\n\n--FormStreamBoundary1349886663601--\n```\n\n *\n */\n\n\n\nvar debug = require('util').debuglog('formstream');\nvar Stream = require('stream');\nvar parseStream = require('pause-stream');\nvar util = require('util');\nvar mime = require('mime');\nvar path = require('path');\nvar fs = require('fs');\nvar destroy = require('destroy');\nvar hex = require('node-hex');\n\nvar PADDING = '--';\nvar NEW_LINE = '\\r\\n';\nvar NEW_LINE_BUFFER =  Buffer.from(NEW_LINE);\n\nfunction FormStream(options) {\n  if (!(this instanceof FormStream)) {\n    return new FormStream(options);\n  }\n\n  FormStream.super_.call(this);\n\n  this._boundary = this._generateBoundary();\n  this._streams = [];\n  this._buffers = [];\n  this._endData = Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE);\n  this._contentLength = 0;\n  this._isAllStreamSizeKnown = true;\n  this._knownStreamSize = 0;\n  this._minChunkSize = options && options.minChunkSize || 0;\n\n  this.isFormStream = true;\n  debug('start boundary\\n%s', this._boundary);\n}\n\nutil.inherits(FormStream, Stream);\nmodule.exports = FormStream;\n\nFormStream.prototype._generateBoundary = function() {\n  // https://github.com/felixge/node-form-data/blob/master/lib/form_data.js#L162\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  return boundary;\n};\n\nFormStream.prototype.setTotalStreamSize = function (size) {\n  // this method should not make any sense if the length of each stream is known.\n  if (this._isAllStreamSizeKnown) {\n    return this;\n  }\n\n  size = size || 0;\n\n  for (var i = 0; i < this._streams.length; i++) {\n    size += this._streams[i][0].length;\n    size += NEW_LINE_BUFFER.length; // stream field end padding size\n  }\n\n  this._knownStreamSize = size;\n  this._isAllStreamSizeKnown = true;\n  debug('set total size: %s', size);\n  return this;\n};\n\nFormStream.prototype.headers = function (options) {\n  var headers = {\n    'Content-Type': 'multipart/form-data; boundary=' + this._boundary\n  };\n\n  // calculate total stream size\n  this._contentLength += this._knownStreamSize;\n  // calculate length of end padding\n  this._contentLength += this._endData.length;\n\n  if (this._isAllStreamSizeKnown) {\n    headers['Content-Length'] = String(this._contentLength);\n  }\n\n  if (options) {\n    for (var k in options) {\n      headers[k] = options[k];\n    }\n  }\n\n  debug('headers: %j', headers);\n  return headers;\n};\n\nFormStream.prototype.file = function (name, filepath, filename, filesize) {\n  if (typeof filename === 'number' && !filesize) {\n    filesize = filename;\n    filename = path.basename(filepath);\n  }\n  if (!filename) {\n    filename = path.basename(filepath);\n  }\n\n  var mimeType = mime.getType(filename);\n  var stream = fs.createReadStream(filepath);\n\n  return this.stream(name, stream, filename, mimeType, filesize);\n};\n\n/**\n * Add a form field\n * @param  {String} name field name\n * @param  {String|Buffer} value field value\n * @param  {String} [mimeType] field mimeType\n * @return {this}\n */\nFormStream.prototype.field = function (name, value, mimeType) {\n  if (!Buffer.isBuffer(value)) {\n    // field(String, Number)\n    // https://github.com/qiniu/nodejs-sdk/issues/123\n    if (typeof value === 'number') {\n      value = String(value);\n    }\n    value = Buffer.from(value);\n  }\n  return this.buffer(name, value, null, mimeType);\n};\n\nFormStream.prototype.stream = function (name, stream, filename, mimeType, size) {\n  if (typeof mimeType === 'number' && !size) {\n    size = mimeType;\n    mimeType = mime.getType(filename);\n  } else if (!mimeType) {\n    mimeType = mime.getType(filename);\n  }\n\n  stream.once('error', this.emit.bind(this, 'error'));\n  // if form stream destroy, also destroy the source stream\n  this.once('destroy', function () {\n    destroy(stream);\n  });\n\n  var leading = this._leading({ name: name, filename: filename }, mimeType);\n\n  var ps = parseStream().pause();\n  stream.pipe(ps);\n\n  this._streams.push([leading, ps]);\n\n  // if the size of this stream is known, plus the total content-length;\n  // otherwise, content-length is unknown.\n  if (typeof size === 'number') {\n    this._knownStreamSize += leading.length;\n    this._knownStreamSize += size;\n    this._knownStreamSize += NEW_LINE_BUFFER.length;\n  } else {\n    this._isAllStreamSizeKnown = false;\n  }\n\n  process.nextTick(this.resume.bind(this));\n\n  return this;\n};\n\nFormStream.prototype.buffer = function (name, buffer, filename, mimeType) {\n  if (filename && !mimeType) {\n    mimeType = mime.getType(filename);\n  }\n\n  var disposition = { name: name };\n  if (filename) {\n    disposition.filename = filename;\n  }\n\n  var leading = this._leading(disposition, mimeType);\n\n  // plus buffer length to total content-length\n  var bufferSize = leading.length + buffer.length + NEW_LINE_BUFFER.length;\n  this._buffers.push(Buffer.concat([leading, buffer, NEW_LINE_BUFFER], bufferSize));  \n  this._contentLength += bufferSize;\n\n  process.nextTick(this.resume.bind(this));\n  if (debug.enabled) {\n    if (buffer.length > 512) {\n      debug('new buffer field, content size: %d\\n%s%s',\n        buffer.length, leading.toString(), hex(buffer.slice(0, 512)));\n    } else {\n      debug('new buffer field, content size: %d\\n%s%s',\n        buffer.length, leading.toString(), hex(buffer));\n    }\n  }\n  return this;\n};\n\nFormStream.prototype._leading = function (disposition, type) {\n  var leading = [PADDING + this._boundary];\n\n  var dispositions = [];\n\n  if (disposition) {\n    for (var k in disposition) {\n      dispositions.push(k + '=\"' + disposition[k] + '\"');\n    }\n  }\n\n  leading.push('Content-Disposition: form-data; ' + dispositions.join('; '));\n  if (type) {\n    leading.push('Content-Type: ' + type);\n  }\n\n  leading.push('');\n  leading.push('');\n  return Buffer.from(leading.join(NEW_LINE));\n};\n\nFormStream.prototype._emitBuffers = function () {\n  if (!this._buffers.length) {\n    return;\n  }\n\n  for (var i = 0; i < this._buffers.length; i++) {\n    this.emit('data', this._buffers[i]);\n  }\n  this._buffers = [];\n};\n\nFormStream.prototype._emitStream = function (item) {\n  var self = this;\n  // item: [ leading, stream ]\n  var streamSize = 0;\n  var chunkCount = 0;\n  const leading = item[0];\n  self.emit('data', leading);\n  chunkCount++;\n  if (debug.enabled) {\n    debug('new stream, chunk index %d\\n%s', chunkCount, leading.toString());\n  }\n\n  var stream = item[1];\n  stream.on('data', function (data) {\n    self.emit('data', data);\n    streamSize += leading.length;\n    chunkCount++;\n    if (debug.enabled) {\n      if (data.length > 512) {\n        debug('stream chunk, size %d, chunk index %d, stream size %d\\n%s......   only show 512 bytes   ......',\n          data.length, chunkCount, streamSize, hex(data.slice(0, 512)));\n      } else {\n        debug('stream chunk, size %d, chunk index %d, stream size %d\\n%s',\n          data.length, chunkCount, streamSize, hex(data));\n      }\n    }\n  });\n  stream.on('end', function () {\n    self.emit('data', NEW_LINE_BUFFER);\n    chunkCount++;\n    debug('stream end, chunk index %d, stream size %d', chunkCount, streamSize);\n    return process.nextTick(self.drain.bind(self));\n  });\n  stream.resume();\n};\n\nFormStream.prototype._emitStreamWithChunkSize = function (item, minChunkSize) {\n  var self = this;\n  // item: [ leading, stream ]\n  var streamSize = 0;\n  var chunkCount = 0;\n  var bufferSize = 0;\n  var buffers = [];\n  const leading = item[0];\n  buffers.push(leading);\n  bufferSize += leading.length;\n  if (debug.enabled) {\n    debug('new stream, with min chunk size: %d\\n%s', minChunkSize, leading.toString());\n  }\n\n  var stream = item[1];\n  stream.on('data', function (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data, 'utf-8');\n    }\n    buffers.push(data);\n    bufferSize += data.length;\n    streamSize += data.length;\n    debug('got stream data size %d, buffer size %d, stream size %d',\n      data.length, bufferSize, streamSize);\n    if (bufferSize >= minChunkSize) {\n      const chunk = Buffer.concat(buffers, bufferSize);\n      buffers = [];\n      bufferSize = 0;\n      self.emit('data', chunk);\n      chunkCount++;\n      if (debug.enabled) {\n        if (chunk.length > 512) {\n          debug('stream chunk, size %d, chunk index %d, stream size %d\\n%s......   only show 512 bytes   ......',\n            chunk.length, chunkCount, streamSize, hex(chunk.slice(0, 512)));\n        } else {\n          debug('stream chunk, size %d, chunk index %d, stream size %d\\n%s',\n            chunk.length, chunkCount, streamSize, hex(chunk));\n        }\n      }\n    }\n  });\n  stream.on('end', function () {\n    buffers.push(NEW_LINE_BUFFER);\n    bufferSize += NEW_LINE_BUFFER.length;\n    const chunk = Buffer.concat(buffers, bufferSize);\n    self.emit('data', chunk);\n    chunkCount++;\n    if (chunk.length > 512) {\n      debug('stream end, size %d, chunk index %d, stream size %d\\n%s......   only show 512 bytes   ......',\n        chunk.length, chunkCount, streamSize, hex(chunk.slice(0, 512)));\n    } else {\n      debug('stream end, size %d, chunk index %d, stream size %d\\n%s',\n        chunk.length, chunkCount, streamSize, hex(chunk));\n    }\n    return process.nextTick(self.drain.bind(self));\n  });\n  stream.resume();\n};\n\nFormStream.prototype._emitEnd = function () {\n  // ending format:\n  //\n  // --{boundary}--\\r\\n\n  this.emit('data', this._endData);\n  this.emit('end');\n  if (debug.enabled) {\n    debug('end boundary\\n%s', this._endData.toString());\n  }\n};\n\nFormStream.prototype.drain = function () {\n  // debug('drain');\n  this._emitBuffers();\n\n  var item = this._streams.shift();\n  if (item) {\n    if (this._minChunkSize && this._minChunkSize > 0) {\n      this._emitStreamWithChunkSize(item, this._minChunkSize);\n    } else {\n      this._emitStream(item);\n    }\n  } else {\n    this._emitEnd();\n  }\n\n  return this;\n};\n\nFormStream.prototype.resume = function () {\n  // debug('resume');\n  this.paused = false;\n\n  if (!this._draining) {\n    this._draining = true;\n    this.drain();\n  }\n\n  return this;\n};\n\nFormStream.prototype.close = FormStream.prototype.destroy = function () {\n  this.emit('destroy');\n  // debug('destroy or close');\n};\n"]}