{"version":3,"sources":["jstoxml.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"exports\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.jstoxml = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_exports) {\n  \n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.toXML = _exports.default = void 0;\n\n  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\n  function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\n  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\n  function _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\n  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\n  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\n  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n  function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n  var ARRAY = \"array\";\n  var BOOLEAN = \"boolean\";\n  var DATE = \"date\";\n  var NULL = \"null\";\n  var NUMBER = \"number\";\n  var OBJECT = \"object\";\n  var SPECIAL_OBJECT = \"special-object\";\n  var STRING = \"string\";\n  var PRIVATE_VARS = [\"_selfCloseTag\", \"_attrs\"];\n  var PRIVATE_VARS_REGEXP = new RegExp(PRIVATE_VARS.join(\"|\"), \"g\");\n  /**\n   * Determines the indent string based on current tree depth.\n   */\n\n  var getIndentStr = function getIndentStr() {\n    var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return indent.repeat(depth);\n  };\n  /**\n   * Sugar function supplementing JS's quirky typeof operator, plus some extra help to detect\n   * \"special objects\" expected by jstoxml.\n   * Example:\n   * getType(new Date());\n   * -> 'date'\n   */\n\n\n  var getType = function getType(val) {\n    return Array.isArray(val) && ARRAY || _typeof(val) === OBJECT && val !== null && val._name && SPECIAL_OBJECT || val instanceof Date && DATE || val === null && NULL || _typeof(val);\n  };\n  /**\n   * Replaces matching values in a string with a new value.\n   * Example:\n   * filterStr('foo&bar', { '&': '&amp;' });\n   * -> 'foo&amp;bar'\n   */\n\n\n  var filterStr = function filterStr() {\n    var inputStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Passthrough/no-op for nonstrings (e.g. number, boolean).\n    if (typeof inputStr !== \"string\") {\n      return inputStr;\n    }\n\n    var regexp = new RegExp(\"(\".concat(Object.keys(filter).join(\"|\"), \")(?!(\\\\w|#)*;)\"), \"g\");\n    return String(inputStr).replace(regexp, function (str, entity) {\n      return filter[entity] || \"\";\n    });\n  };\n  /**\n   * Maps an object or array of arribute keyval pairs to a string.\n   * Examples:\n   * { foo: 'bar', baz: 'g' } -> 'foo=\"bar\" baz=\"g\"'\n   * [ { ⚡: true }, { foo: 'bar' } ] -> '⚡ foo=\"bar\"'\n   */\n\n\n  var getAttributeKeyVals = function getAttributeKeyVals() {\n    var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var filter = arguments.length > 1 ? arguments[1] : undefined;\n    var keyVals = [];\n\n    if (Array.isArray(attributes)) {\n      // Array containing complex objects and potentially duplicate attributes.\n      keyVals = attributes.map(function (attr) {\n        var key = Object.keys(attr)[0];\n        var val = attr[key];\n        var filteredVal = filter ? filterStr(val, filter) : val;\n        var valStr = filteredVal === true ? \"\" : \"=\\\"\".concat(filteredVal, \"\\\"\");\n        return \"\".concat(key).concat(valStr);\n      });\n    } else {\n      var keys = Object.keys(attributes);\n      keyVals = keys.map(function (key) {\n        // Simple object - keyval pairs.\n        // For boolean true, simply output the key.\n        var filteredVal = filter ? filterStr(attributes[key], filter) : attributes[key];\n        var valStr = attributes[key] === true ? \"\" : \"=\\\"\".concat(filteredVal, \"\\\"\");\n        return \"\".concat(key).concat(valStr);\n      });\n    }\n\n    return keyVals;\n  };\n  /**\n   * Converts an attributes object/array to a string of keyval pairs.\n   * Example:\n   * formatAttributes({ a: 1, b: 2 })\n   * -> 'a=\"1\" b=\"2\"'\n   */\n\n\n  var formatAttributes = function formatAttributes() {\n    var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var filter = arguments.length > 1 ? arguments[1] : undefined;\n    var keyVals = getAttributeKeyVals(attributes, filter);\n    if (keyVals.length === 0) return \"\";\n    var keysValsJoined = keyVals.join(\" \");\n    return \" \".concat(keysValsJoined);\n  };\n  /**\n   * Converts an object to a jstoxml array.\n   * Example:\n   * objToArray({ foo: 'bar', baz: 2 });\n   * ->\n   * [\n   *   {\n   *     _name: 'foo',\n   *     _content: 'bar'\n   *   },\n   *   {\n   *     _name: 'baz',\n   *     _content: 2\n   *   }\n   * ]\n   */\n\n\n  var objToArray = function objToArray() {\n    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Object.keys(obj).map(function (key) {\n      return {\n        _name: key,\n        _content: obj[key]\n      };\n    });\n  };\n  /**\n   * Determines if a value is a primitive JavaScript value (not including Symbol).\n   * Example:\n   * isPrimitive(4);\n   * -> true\n   */\n\n\n  var PRIMITIVE_TYPES = [STRING, NUMBER, BOOLEAN];\n\n  var isPrimitive = function isPrimitive(val) {\n    return PRIMITIVE_TYPES.includes(getType(val));\n  };\n  /**\n   * Determines if a value is a simple primitive type that can fit onto one line.  Needed for\n   * determining any needed indenting and line breaks.\n   * Example:\n   * isSimpleType(new Date());\n   * -> true\n   */\n\n\n  var SIMPLE_TYPES = [].concat(PRIMITIVE_TYPES, [DATE, SPECIAL_OBJECT]);\n\n  var isSimpleType = function isSimpleType(val) {\n    return SIMPLE_TYPES.includes(getType(val));\n  };\n  /**\n   * Determines if an XML string is a simple primitive, or contains nested data.\n   * Example:\n   * isSimpleXML('<foo />');\n   * -> false\n   */\n\n\n  var isSimpleXML = function isSimpleXML(xmlStr) {\n    return !xmlStr.match(\"<\");\n  };\n  /**\n   * Assembles an XML header as defined by the config.\n   */\n\n\n  var DEFAULT_XML_HEADER = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n\n  var getHeaderString = function getHeaderString(_ref) {\n    var header = _ref.header,\n        indent = _ref.indent,\n        isOutputStart = _ref.isOutputStart;\n    var shouldOutputHeader = header && isOutputStart;\n    if (!shouldOutputHeader) return \"\";\n    var shouldUseDefaultHeader = _typeof(header) === BOOLEAN; // return `${shouldUseDefaultHeader ? DEFAULT_XML_HEADER : header}${indent ? \"\\n\" : \"\"\n    //   }`;\n\n    return shouldUseDefaultHeader ? DEFAULT_XML_HEADER : header;\n  };\n  /**\n   * Recursively traverses an object tree and converts the output to an XML string.\n   * Example:\n   * toXML({ foo: 'bar' });\n   * -> <foo>bar</foo>\n   */\n\n\n  var defaultEntityFilter = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    \"&\": \"&amp;\"\n  };\n\n  var toXML = function toXML() {\n    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _config$depth = config.depth,\n        depth = _config$depth === void 0 ? 0 : _config$depth,\n        indent = config.indent,\n        _isFirstItem = config._isFirstItem,\n        _config$_isOutputStar = config._isOutputStart,\n        _isOutputStart = _config$_isOutputStar === void 0 ? true : _config$_isOutputStar,\n        header = config.header,\n        _config$attributesFil = config.attributesFilter,\n        rawAttributesFilter = _config$attributesFil === void 0 ? {} : _config$attributesFil,\n        _config$filter = config.filter,\n        rawFilter = _config$filter === void 0 ? {} : _config$filter;\n\n    var shouldTurnOffAttributesFilter = typeof rawAttributesFilter === 'boolean' && !rawAttributesFilter;\n    var attributesFilter = shouldTurnOffAttributesFilter ? {} : _objectSpread(_objectSpread(_objectSpread({}, defaultEntityFilter), {\n      '\"': \"&quot;\"\n    }), rawAttributesFilter);\n    var shouldTurnOffFilter = typeof rawFilter === 'boolean' && !rawFilter;\n    var filter = shouldTurnOffFilter ? {} : _objectSpread(_objectSpread({}, defaultEntityFilter), rawFilter); // Determine indent string based on depth.\n\n    var indentStr = getIndentStr(indent, depth); // For branching based on value type.\n\n    var valType = getType(obj);\n    var headerStr = getHeaderString({\n      header: header,\n      indent: indent,\n      depth: depth,\n      isOutputStart: _isOutputStart\n    });\n    var isOutputStart = _isOutputStart && !headerStr && _isFirstItem && depth === 0;\n    var outputStr = \"\";\n\n    switch (valType) {\n      case \"special-object\":\n        {\n          // Processes a specially-formatted object used by jstoxml.\n          var _name = obj._name,\n              _content = obj._content; // Output text content without a tag wrapper.\n\n          if (_content === null) {\n            outputStr = _name;\n            break;\n          } // Handles arrays of primitive values. (#33)\n\n\n          var isArrayOfPrimitives = Array.isArray(_content) && _content.every(isPrimitive);\n\n          if (isArrayOfPrimitives) {\n            var primitives = _content.map(function (a) {\n              return toXML({\n                _name: _name,\n                _content: a\n              }, _objectSpread(_objectSpread({}, config), {}, {\n                depth: depth,\n                _isOutputStart: false\n              }));\n            });\n\n            return primitives.join('');\n          } // Don't output private vars (such as _attrs).\n\n\n          if (_name.match(PRIVATE_VARS_REGEXP)) break; // Process the nested new value and create new config.\n\n          var newVal = toXML(_content, _objectSpread(_objectSpread({}, config), {}, {\n            depth: depth + 1,\n            _isOutputStart: isOutputStart\n          }));\n          var newValType = getType(newVal);\n          var isNewValSimple = isSimpleXML(newVal); // Pre-tag output (indent and line breaks).\n\n          var preIndentStr = indent && !isOutputStart ? \"\\n\" : \"\";\n          var preTag = \"\".concat(preIndentStr).concat(indentStr); // Special handling for comments, preserving preceding line breaks/indents.\n\n          if (_name === '_comment') {\n            outputStr += \"\".concat(preTag, \"<!-- \").concat(_content, \" -->\");\n            break;\n          } // Tag output.\n\n\n          var valIsEmpty = newValType === \"undefined\" || newVal === \"\";\n          var shouldSelfClose = _typeof(obj._selfCloseTag) === BOOLEAN ? valIsEmpty && obj._selfCloseTag : valIsEmpty;\n          var selfCloseStr = shouldSelfClose ? \"/\" : \"\";\n          var attributesString = formatAttributes(obj._attrs, attributesFilter);\n          var tag = \"<\".concat(_name).concat(attributesString).concat(selfCloseStr, \">\"); // Post-tag output (closing tag, indent, line breaks).\n\n          var preTagCloseStr = indent && !isNewValSimple ? \"\\n\".concat(indentStr) : \"\";\n          var postTag = !shouldSelfClose ? \"\".concat(newVal).concat(preTagCloseStr, \"</\").concat(_name, \">\") : \"\";\n          outputStr += \"\".concat(preTag).concat(tag).concat(postTag);\n          break;\n        }\n\n      case \"object\":\n        {\n          // Iterates over keyval pairs in an object, converting each item to a special-object.\n          var keys = Object.keys(obj);\n          var outputArr = keys.map(function (key, index) {\n            var newConfig = _objectSpread(_objectSpread({}, config), {}, {\n              _isFirstItem: index === 0,\n              _isLastItem: index + 1 === keys.length,\n              _isOutputStart: isOutputStart\n            });\n\n            var outputObj = {\n              _name: key\n            };\n\n            if (getType(obj[key]) === \"object\") {\n              // Sub-object contains an object.\n              // Move private vars up as needed.  Needed to support certain types of objects\n              // E.g. { foo: { _attrs: { a: 1 } } } -> <foo a=\"1\"/>\n              PRIVATE_VARS.forEach(function (privateVar) {\n                var val = obj[key][privateVar];\n\n                if (typeof val !== \"undefined\") {\n                  outputObj[privateVar] = val;\n                  delete obj[key][privateVar];\n                }\n              });\n              var hasContent = typeof obj[key]._content !== \"undefined\";\n\n              if (hasContent) {\n                // _content has sibling keys, so pass as an array (edge case).\n                // E.g. { foo: 'bar', _content: { baz: 2 } } -> <foo>bar</foo><baz>2</baz>\n                if (Object.keys(obj[key]).length > 1) {\n                  var newContentObj = Object.assign({}, obj[key]);\n                  delete newContentObj._content;\n                  outputObj._content = [].concat(_toConsumableArray(objToArray(newContentObj)), [obj[key]._content]);\n                }\n              }\n            } // Fallthrough: just pass the key as the content for the new special-object.\n\n\n            if (typeof outputObj._content === \"undefined\") outputObj._content = obj[key];\n            var xml = toXML(outputObj, newConfig, key);\n            return xml;\n          }, config);\n          outputStr = outputArr.join('');\n          break;\n        }\n\n      case \"function\":\n        {\n          // Executes a user-defined function and returns output.\n          var fnResult = obj(config);\n          outputStr = toXML(fnResult, config);\n          break;\n        }\n\n      case \"array\":\n        {\n          // Iterates and converts each value in an array.\n          var _outputArr = obj.map(function (singleVal, index) {\n            var newConfig = _objectSpread(_objectSpread({}, config), {}, {\n              _isFirstItem: index === 0,\n              _isLastItem: index + 1 === obj.length,\n              _isOutputStart: isOutputStart\n            });\n\n            return toXML(singleVal, newConfig);\n          });\n\n          outputStr = _outputArr.join('');\n          break;\n        }\n      // number, string, boolean, date, null, etc\n\n      default:\n        {\n          outputStr = filterStr(obj, filter);\n          break;\n        }\n    }\n\n    return \"\".concat(headerStr).concat(outputStr);\n  };\n\n  _exports.toXML = toXML;\n  var _default = {\n    toXML: toXML\n  };\n  _exports.default = _default;\n});\n"]}